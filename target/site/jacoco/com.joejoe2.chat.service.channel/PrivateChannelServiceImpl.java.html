<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PrivateChannelServiceImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">chat</a> &gt; <a href="index.source.html" class="el_package">com.joejoe2.chat.service.channel</a> &gt; <span class="el_source">PrivateChannelServiceImpl.java</span></div><h1>PrivateChannelServiceImpl.java</h1><pre class="source lang-java linenums">package com.joejoe2.chat.service.channel;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.joejoe2.chat.data.PageRequest;
import com.joejoe2.chat.data.message.PrivateMessageDto;
import com.joejoe2.chat.data.SliceList;
import com.joejoe2.chat.data.channel.profile.PrivateChannelProfile;
import com.joejoe2.chat.exception.AlreadyExist;
import com.joejoe2.chat.exception.ChannelDoesNotExist;
import com.joejoe2.chat.exception.InvalidOperation;
import com.joejoe2.chat.exception.UserDoesNotExist;
import com.joejoe2.chat.models.PrivateChannel;
import com.joejoe2.chat.models.User;
import com.joejoe2.chat.repository.channel.PrivateChannelRepository;
import com.joejoe2.chat.repository.user.UserRepository;
import com.joejoe2.chat.utils.SseUtil;
import com.joejoe2.chat.utils.SubjectPrefix;
import com.joejoe2.chat.validation.validator.PageRequestValidator;
import com.joejoe2.chat.validation.validator.UUIDValidator;
import io.nats.client.Connection;
import io.nats.client.Dispatcher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Slice;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import javax.annotation.PostConstruct;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Service
<span class="fc" id="L41">public class PrivateChannelServiceImpl implements PrivateChannelService {</span>
    @Autowired
    UserRepository userRepository;
    @Autowired
    PrivateChannelRepository channelRepository;
    @Autowired
    ObjectMapper objectMapper;
    @Autowired
    UUIDValidator uuidValidator;
    @Autowired
    PageRequestValidator pageValidator;

<span class="fc" id="L53">    Map&lt;String, Set&lt;SseEmitter&gt;&gt; listeningUsers = new ConcurrentHashMap&lt;&gt;();</span>
    private static final int MAX_CONNECT_DURATION = 15;
<span class="fc" id="L55">    private ScheduledExecutorService scheduler = new ScheduledThreadPoolExecutor(1);</span>

<span class="fc" id="L57">    private final String SUBJECT_PREFIX = SubjectPrefix.PRIVATE_CHANNEL;</span>
<span class="fc" id="L58">    private static final Logger logger = LoggerFactory.getLogger(PrivateChannelService.class);</span>

    @Autowired
    Connection connection;

    Dispatcher dispatcher;

    /**
     * create nats dispatcher with shared message handler for all
     * private messages after bean is constructed, the shared message
     * handler will deliver private messages to registered users(subscribers)
     * on this server
     */
    @PostConstruct
    private void initNats() {
<span class="fc" id="L73">        dispatcher = connection.createDispatcher((msg) -&gt; {</span>
            try {
<span class="nc" id="L75">                sendToSubscribers(listeningUsers.get(msg.getSubject().replace(SUBJECT_PREFIX, &quot;&quot;)),</span>
<span class="nc" id="L76">                        objectMapper.readValue(new String(msg.getData(), StandardCharsets.UTF_8),</span>
                                PrivateMessageDto.class));
<span class="nc" id="L78">            } catch (JsonProcessingException e) {</span>
<span class="nc" id="L79">                e.printStackTrace();</span>
<span class="nc" id="L80">            }</span>
<span class="nc" id="L81">        });</span>
<span class="fc" id="L82">    }</span>

    /**
     * deliver private messages to registered users(subscribers)
     */
    private void sendToSubscribers(Set&lt;SseEmitter&gt; subscribers, PrivateMessageDto message) {
<span class="nc" id="L88">        new ArrayList&lt;&gt;(subscribers).parallelStream().forEach((subscriber) -&gt; {</span>
            try {
<span class="nc" id="L90">                SseUtil.sendMessageEvent(subscriber, message);</span>
<span class="nc" id="L91">            } catch (Exception e) {</span>
<span class="nc" id="L92">                logger.error(e.getMessage());</span>
<span class="nc" id="L93">            }</span>
<span class="nc" id="L94">        });</span>
<span class="nc" id="L95">    }</span>

    @Override
    public SseEmitter subscribe(String fromUserId) throws UserDoesNotExist {
<span class="nc" id="L99">        userRepository.findById(uuidValidator.validate(fromUserId))</span>
<span class="nc" id="L100">                .orElseThrow(() -&gt; new UserDoesNotExist(&quot;user is not exist !&quot;));</span>

<span class="nc" id="L102">        SseEmitter subscriber = createUserSubscriber(fromUserId);</span>
<span class="nc" id="L103">        SseUtil.sendConnectEvent(subscriber);</span>
<span class="nc" id="L104">        return subscriber;</span>
    }

    /**
     * create SseEmitter instance(subscriber)
     * @param userId
     * @return
     */
    private SseEmitter createUserSubscriber(String userId) {
<span class="nc" id="L113">        SseEmitter subscriber = new SseEmitter(120000L);</span>
<span class="nc" id="L114">        addUnSubscribeTriggers(userId, subscriber);</span>
<span class="nc" id="L115">        listenToUser(subscriber, userId);</span>
<span class="nc" id="L116">        return subscriber;</span>
    }

    /**
     * add UnSubscribe listener to SseEmitter instance(subscriber), and force
     * unsubscribing after MAX_CONNECT_DURATION MINUTES
     * @param userId
     * @param subscriber
     */
    private void addUnSubscribeTriggers(String userId, SseEmitter subscriber){
<span class="nc" id="L126">        Runnable unSubscribe =  () -&gt;listeningUsers.compute(userId, (key, val) -&gt; {</span>
            //remove from subscribers
<span class="nc bnc" id="L128" title="All 2 branches missed.">            if (val != null) val.remove(subscriber);</span>
            //unsubscribe if no subscribers
<span class="nc bnc" id="L130" title="All 4 branches missed.">            if (val == null || val.isEmpty()) {</span>
<span class="nc" id="L131">                dispatcher.unsubscribe(SUBJECT_PREFIX + userId);</span>
<span class="nc" id="L132">                return null;</span>
            }
<span class="nc" id="L134">            return val;</span>
        });
<span class="nc" id="L136">        SseUtil.addSseCallbacks(subscriber, unSubscribe);</span>
<span class="nc" id="L137">        scheduler.schedule(unSubscribe, MAX_CONNECT_DURATION, TimeUnit.MINUTES);</span>
<span class="nc" id="L138">    }</span>

    /**
     * register SseEmitter instance(subscriber) and channelId to nats dispatcher
     * @param subscriber
     * @param userId
     */
    private void listenToUser(SseEmitter subscriber, String userId) {
<span class="nc" id="L146">        listeningUsers.compute(userId, (key, subscribers) -&gt; {</span>
<span class="nc bnc" id="L147" title="All 2 branches missed.">            if (subscribers == null) {</span>
<span class="nc" id="L148">                subscribers = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
            }
<span class="nc" id="L150">            subscribers.add(subscriber);</span>
<span class="nc" id="L151">            dispatcher.subscribe(SUBJECT_PREFIX + userId);</span>
<span class="nc" id="L152">            return subscribers;</span>
        });
<span class="nc" id="L154">    }</span>

    @Override
    public PrivateChannelProfile createChannelBetween(String fromUserId, String toUserId) throws UserDoesNotExist, AlreadyExist, InvalidOperation {
<span class="fc" id="L158">        User user = userRepository.findById(uuidValidator.validate(fromUserId))</span>
<span class="pc" id="L159">                .orElseThrow(() -&gt; new UserDoesNotExist(&quot;user is not exist !&quot;));</span>
<span class="fc" id="L160">        User targetUser = userRepository.findById(uuidValidator.validate(toUserId))</span>
<span class="pc" id="L161">                .orElseThrow(() -&gt; new UserDoesNotExist(&quot;target user is not exist !&quot;));</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (user.equals(targetUser))</span>
<span class="fc" id="L163">            throw new InvalidOperation(&quot;cannot chat with yourself !&quot;);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">        if (channelRepository.isPrivateChannelExistBetween(user, targetUser))</span>
<span class="fc" id="L165">            throw new AlreadyExist(&quot;channel between &quot; + user.getUserName() + &quot; and &quot; + targetUser.getUserName() + &quot; is already exist !&quot;);</span>

<span class="fc" id="L167">        PrivateChannel channel = new PrivateChannel(new HashSet&lt;&gt;(Arrays.asList(user, targetUser)));</span>
<span class="fc" id="L168">        channelRepository.saveAndFlush(channel);</span>
<span class="fc" id="L169">        return new PrivateChannelProfile(channel);</span>
    }

    @Override
    @Transactional(readOnly = true)
    public SliceList&lt;PrivateChannelProfile&gt; getAllChannels(String ofUserId, PageRequest pageRequest) throws UserDoesNotExist {
<span class="fc" id="L175">        org.springframework.data.domain.PageRequest paging = pageValidator.validate(pageRequest);</span>
<span class="fc" id="L176">        User user = userRepository.findById(uuidValidator.validate(ofUserId))</span>
<span class="pc" id="L177">                .orElseThrow(() -&gt; new UserDoesNotExist(&quot;user is not exist !&quot;));</span>

<span class="fc" id="L179">        Slice&lt;PrivateChannel&gt; slice = channelRepository.findByIsUserInMembers(user, paging);</span>

<span class="fc" id="L181">        return new SliceList&lt;&gt;(slice.getNumber(), slice.getSize(),</span>
<span class="fc" id="L182">                slice.stream().map(PrivateChannelProfile::new)</span>
<span class="fc" id="L183">                        .collect(Collectors.toList()), slice.hasNext());</span>
    }

    @Override
    @Transactional(readOnly = true)
    public PrivateChannelProfile getChannelProfile(String ofUserId, String channelId) throws UserDoesNotExist, ChannelDoesNotExist, InvalidOperation {
<span class="fc" id="L189">        User user = userRepository.findById(uuidValidator.validate(ofUserId))</span>
<span class="pc" id="L190">                .orElseThrow(() -&gt; new UserDoesNotExist(&quot;user is not exist !&quot;));</span>
<span class="fc" id="L191">        PrivateChannel channel = channelRepository.findById(uuidValidator.validate(channelId))</span>
<span class="pc" id="L192">                .orElseThrow(() -&gt; new ChannelDoesNotExist(&quot;channel is not exist !&quot;));</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        if (!channel.getMembers().contains(user))</span>
<span class="fc" id="L194">            throw new InvalidOperation(&quot;user is not in members of the channel !&quot;);</span>

<span class="fc" id="L196">        return new PrivateChannelProfile(channel);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>