<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PublicChannelServiceImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">chat</a> &gt; <a href="index.source.html" class="el_package">com.joejoe2.chat.service.channel</a> &gt; <span class="el_source">PublicChannelServiceImpl.java</span></div><h1>PublicChannelServiceImpl.java</h1><pre class="source lang-java linenums">package com.joejoe2.chat.service.channel;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.joejoe2.chat.data.PageList;
import com.joejoe2.chat.data.message.PublicMessageDto;
import com.joejoe2.chat.data.channel.profile.PublicChannelProfile;
import com.joejoe2.chat.exception.AlreadyExist;
import com.joejoe2.chat.exception.ChannelDoesNotExist;
import com.joejoe2.chat.models.PublicChannel;
import com.joejoe2.chat.repository.channel.PublicChannelRepository;
import com.joejoe2.chat.utils.SseUtil;
import com.joejoe2.chat.utils.SubjectPrefix;
import com.joejoe2.chat.validation.validator.PageRequestValidator;
import com.joejoe2.chat.validation.validator.PublicChannelNameValidator;
import com.joejoe2.chat.validation.validator.UUIDValidator;
import io.nats.client.Connection;
import io.nats.client.Dispatcher;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.servlet.mvc.method.annotation.SseEmitter;

import javax.annotation.PostConstruct;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledThreadPoolExecutor;
import java.util.concurrent.TimeUnit;
import java.util.stream.Collectors;

@Service
<span class="fc" id="L39">public class PublicChannelServiceImpl implements PublicChannelService {</span>
    @Autowired
    PublicChannelRepository channelRepository;
    @Autowired
    ObjectMapper objectMapper;
    @Autowired
    UUIDValidator uuidValidator;
    @Autowired
    PublicChannelNameValidator channelNameValidator;
    @Autowired
    PageRequestValidator pageValidator;

<span class="fc" id="L51">    Map&lt;String, Set&lt;SseEmitter&gt;&gt; listeningChannels = new ConcurrentHashMap&lt;&gt;();</span>
    private static final int MAX_CONNECT_DURATION = 15;
<span class="fc" id="L53">    private ScheduledExecutorService scheduler = new ScheduledThreadPoolExecutor(1);</span>

<span class="fc" id="L55">    private static final Logger logger = LoggerFactory.getLogger(PublicChannelService.class);</span>

    @Autowired
    Connection connection;

    Dispatcher dispatcher;

    /**
     * create nats dispatcher with shared message handler for all
     * public messages after bean is constructed, the shared message
     * handler will deliver public messages to registered subscribers
     * on this server
     */
    @PostConstruct
    private void initNats() {
<span class="fc" id="L70">        dispatcher = connection.createDispatcher((msg) -&gt; {</span>
            try {
<span class="nc" id="L72">                String channel = msg.getSubject().replace(SubjectPrefix.PUBLIC_CHANNEL, &quot;&quot;);</span>
<span class="nc" id="L73">                sendToSubscribers(listeningChannels.get(channel),</span>
<span class="nc" id="L74">                        objectMapper.readValue(new String(msg.getData(), StandardCharsets.UTF_8),</span>
                                PublicMessageDto.class));
<span class="nc" id="L76">            } catch (JsonProcessingException e) {</span>
<span class="nc" id="L77">                e.printStackTrace();</span>
<span class="nc" id="L78">            }</span>
<span class="nc" id="L79">        });</span>
<span class="fc" id="L80">    }</span>

    /**
     * deliver public messages to registered subscribers
     */
    private void sendToSubscribers(Set&lt;SseEmitter&gt; subscribers, PublicMessageDto message) {
<span class="nc" id="L86">        new ArrayList&lt;&gt;(subscribers).parallelStream().forEach((subscriber) -&gt; {</span>
            try {
<span class="nc" id="L88">                SseUtil.sendMessageEvent(subscriber, message);</span>
<span class="nc" id="L89">            } catch (Exception e) {</span>
<span class="nc" id="L90">                logger.error(e.getMessage());</span>
<span class="nc" id="L91">            }</span>
<span class="nc" id="L92">        });</span>
<span class="nc" id="L93">    }</span>

    @Override
    public SseEmitter subscribe(String channelId) throws ChannelDoesNotExist {
<span class="nc" id="L97">        channelRepository.findById(uuidValidator.validate(channelId))</span>
<span class="nc" id="L98">                .orElseThrow(() -&gt; new ChannelDoesNotExist(&quot;channel is not exist !&quot;));</span>

<span class="nc" id="L100">        SseEmitter subscriber = createChannelSubscriber(channelId);</span>
<span class="nc" id="L101">        SseUtil.sendConnectEvent(subscriber);</span>
<span class="nc" id="L102">        return subscriber;</span>
    }

    /**
     * create SseEmitter instance(subscriber)
     * @param channelId
     * @return
     */
    private SseEmitter createChannelSubscriber(String channelId) {
<span class="nc" id="L111">        SseEmitter subscriber = new SseEmitter(120000L);</span>
<span class="nc" id="L112">        addUnSubscribeTriggers(channelId, subscriber);</span>
<span class="nc" id="L113">        listenToChannel(subscriber, channelId);</span>
<span class="nc" id="L114">        return subscriber;</span>
    }

    /**
     * add UnSubscribe listener to SseEmitter instance(subscriber), and force
     * unsubscribing after MAX_CONNECT_DURATION MINUTES
     * @param channelId
     * @param subscriber
     */
    private void addUnSubscribeTriggers(String channelId, SseEmitter subscriber){
<span class="nc" id="L124">        Runnable unSubscribe =  () -&gt; listeningChannels.compute(channelId, (key, subscribers) -&gt; {</span>
<span class="nc bnc" id="L125" title="All 2 branches missed.">            if (subscribers != null) subscribers.remove(subscriber);</span>
<span class="nc bnc" id="L126" title="All 4 branches missed.">            if (subscribers == null || subscribers.isEmpty()) {</span>
<span class="nc" id="L127">                dispatcher.unsubscribe(SubjectPrefix.PUBLIC_CHANNEL + channelId);</span>
<span class="nc" id="L128">                return null;</span>
            }
<span class="nc" id="L130">            return subscribers;</span>
        });
<span class="nc" id="L132">        SseUtil.addSseCallbacks(subscriber, unSubscribe);</span>
<span class="nc" id="L133">        scheduler.schedule(unSubscribe, MAX_CONNECT_DURATION, TimeUnit.MINUTES);</span>
<span class="nc" id="L134">    }</span>

    /**
     * register SseEmitter instance(subscriber) and channelId to nats dispatcher
     * @param subscriber
     * @param channelId
     */
    private void listenToChannel(SseEmitter subscriber, String channelId) {
<span class="nc" id="L142">        listeningChannels.compute(channelId, (key, subscribers) -&gt; {</span>
            //create new subscribers set
<span class="nc bnc" id="L144" title="All 2 branches missed.">            if (subscribers == null) {</span>
<span class="nc" id="L145">                subscribers = Collections.synchronizedSet(new HashSet&lt;&gt;());</span>
            }
            //add to subscribers
<span class="nc" id="L148">            subscribers.add(subscriber);</span>
            //subscribe to nats
<span class="nc" id="L150">            dispatcher.subscribe(SubjectPrefix.PUBLIC_CHANNEL + channelId);</span>
<span class="nc" id="L151">            return subscribers;</span>
        });
<span class="nc" id="L153">    }</span>

    @Override
    public PublicChannelProfile createChannel(String channelName) throws AlreadyExist {
<span class="fc bfc" id="L157" title="All 2 branches covered.">        if (channelRepository.findByName(channelNameValidator.validate(channelName)).isPresent())</span>
<span class="fc" id="L158">            throw new AlreadyExist(&quot;channel name is already exist !&quot;);</span>

<span class="fc" id="L160">        PublicChannel channel = new PublicChannel(channelName);</span>
<span class="fc" id="L161">        channelRepository.saveAndFlush(channel);</span>
<span class="fc" id="L162">        return new PublicChannelProfile(channel);</span>
    }

    @Override
    @Transactional(readOnly = true)
    public PageList&lt;PublicChannelProfile&gt; getAllChannels(com.joejoe2.chat.data.PageRequest pageRequest) {
<span class="fc" id="L168">        PageRequest paging = pageValidator.validate(pageRequest);</span>
<span class="fc" id="L169">        Page&lt;PublicChannel&gt; page = channelRepository</span>
<span class="fc" id="L170">                .findAll(paging.withSort(Sort.by(Sort.Direction.ASC, &quot;name&quot;)));</span>
<span class="fc" id="L171">        List&lt;PublicChannelProfile&gt; profiles = page.getContent().stream()</span>
<span class="fc" id="L172">                .map((PublicChannelProfile::new)).collect(Collectors.toList());</span>

<span class="fc" id="L174">        return new PageList&lt;&gt;(page.getTotalElements(), page.getNumber(),</span>
<span class="fc" id="L175">                page.getTotalPages(), page.getSize(), profiles);</span>
    }

    @Override
    @Transactional(readOnly = true)
    public PublicChannelProfile getChannelProfile(String channelId) throws ChannelDoesNotExist {
<span class="fc" id="L181">        PublicChannel channel = channelRepository.findById(uuidValidator.validate(channelId))</span>
<span class="fc" id="L182">                .orElseThrow(() -&gt; new ChannelDoesNotExist(&quot;channel is not exist !&quot;));</span>

<span class="fc" id="L184">        return new PublicChannelProfile(channel);</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>